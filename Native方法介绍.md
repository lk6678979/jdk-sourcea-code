# Java中Native关键字
## 1. 了解Native的概念
  在JVM的体系结构中有一个Java Native Interface模块，称为Java本地库接口，它的作用是融合不同的编程语言为Java所用。Java是一个跨平台的语言，既然是跨了平台，所付出的代价就是牺牲一些对底层的控制，而Java要实现对底层的控制，就需要借助一些其他语言的方法，这个就是native的作用。
## 2. Java为什么要使用Native方法
  因为要兼顾到跨平台，所以很多对底层的操作就不能有太强的耦合。有时java需要与java外面的环境交互，比如底层的操作系统或者某些硬件，这也是本地方法存在的主要原因。通过使用本地方法，我们只需要调用它暴露给我们的接口，而不需要了解java应用之外的繁琐的细节。
## 3. 什么是native方法 
  一个Native method就是一个java调用非java代码的接口：该方法由非java语言实现，比如C、C++等。 
   Java中的本地方法栈就是这种功能，它与java虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。  
   Navtive 方法是 Java 通过 JNI（Java本地库接口） 直接调用本地 C/C++ 库，Native方法相当于 C/C++ 暴露给 Java 的一个接口，Java 通过调用这个接口从而调用到 C/C++ 方法。当线程调用 Java 方法时，虚拟机会创建一个栈帧并压入 Java 虚拟机栈。然而当它调用的是 native 方法时，虚拟机会保持 Java 虚拟机栈不变，也不会向 Java 虚拟机栈中压入新的栈帧，虚拟机只是简单地动态连接并直接调用指定的 native 方法。
   在定义一个native method时，并不提供实现体（有些像定义一个java interface），因为其实现体是由非java语言在外面实现的。下面给了一个示例：
```java
package java.lang;
 
public class Object { 
    
    ......
    
    public final native Class<?> getClass(); 
    
    public native int hashCode(); 
    
    protected native Object clone() throws CloneNotSupportedException; 
    
    public final native void notify(); 
    
    public final native void notifyAll(); 
    
    public final native void wait(long timeout) throws InterruptedException; 

    ......
 
} 
```
 native可以与所有其他的java标识符连用，abstract除外。这是合理的，因为native暗示这些方法室友实现体的，只不过它们不是用java实现的，但abstract却显然的指明这些方法无实现体。
 native修饰的方法并不会给调用它的类造成任何影响，它与其他method一样可以返回任何java类型。我们可以将它看做是一个正常的java方法来使用。
  
## 4. JAVA如何加载和使用native申明的外部方法
* 如果一个方法描述符内有native，那么这个方法将成为Java Native Interface中的一部分，这个描述符块将有一个指向该方法的实现的指针。  
* native方法的实现在一些DLL文件内，DLL会被操作系统加载到java程序的地址空间，这个空间称为Java Native Method Libraries。  
* 当一个带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。当本地方法被调用之前，这些DLL才会被加载，这是通过调用java.system.loadLibrary()实现的。

## 5. JAVA如何加载DLL
* Java的System.load 和 System.loadLibrary都可以用来加载库文件
* System.load举例：可以这样载入一个windows平台下JNI库文件：
```
System.load("C://Documents and Settings//TestJNI.dll"); //绝对路径
```
* System.loadLibrary参数为库文件名,例如你可以这样载入一个windows平台下JNI库文件
```
System.loadLibrary ("TestJNI");
```
* System.loadLibrary参数中的TestJNI必须在 java.library.path这一jvm变量所指向的路径中，可以通过如下方法获得该变量的值：
```
System.getProperty("java.library.path");
```
* 默认情况下，Windows平台下包含下面的路径：  
  1）和jre相关的目录  
  2）程序当前目录  
  3）Windows目录  
  4）系统目录(system32)  
  5）系统环境变量path指定的目录  
* 在linux下添加一个java.library.path的方法如下：
  在/etc/profile 后面加上一行 export LB_LIBRARY_PATH=路径
* 在执行程序的时候可以显示指定， -Djava.library.path=路径，这种会清除掉预设置的java.library.path的值 。实例如下：
```
java -jar -Djava.library.path=/home/fly/Desktop/sound_dream sound.war
```
## 5. JAVA调用DLL的HelloWord
我们需要按照下班方便的步骤进行：
### 5.1 创建一个Java类，里面包含着一个 native 的方法和加载库的方法 loadLibrary。HelloNative.java 代码如下：
```java
public class HelloNative
{
    static
    {
        System.loadLibrary("HelloNative");
    }
     
    public static native void sayHello();
     
    @SuppressWarnings("static-access")
    public static void main(String[] args)
    {
        new HelloNative().sayHello();
    }
}
```
首先让大家注意的是native方法，那个加载库的到后面也起作用。native 关键字告诉编译器（其实是JVM）调用的是该方法在外部定义，这里指的是C。如果大家直接运行这个代码，  JVM会告之：“A Java Exception has occurred.”控制台输出如下：
```
Exception in thread "main" java.lang.UnsatisfiedLinkError: no HelloNative in java.library.path
    at java.lang.ClassLoader.loadLibrary(Unknown Source)
    at java.lang.Runtime.loadLibrary0(Unknown Source)
    at java.lang.System.loadLibrary(Unknown Source)
    at HelloNative.<clinit>(HelloNative.java:5)
```
这是程序使用它的时候，虚拟机说不知道如何找到sayHello。
### 5.2 运行javah，得到包含该方法的C声明头文件.h
将HelloNative.java ，简单地 javac javah就得到了下面的 HelloNative.h文件 ：
```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloNative */
 
#ifndef _Included_HelloNative
#define _Included_HelloNative
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloNative
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloNative_sayHello
  (JNIEnv *, jclass);
 
#ifdef __cplusplus
}
#endif
#endif
```
jni.h 这个文件，在/%JAVA_HOME%include
### 5.3 根据头文件，写C实现本地方法。
这里我们简单地实现这个sayHello方法如下：
```
#include "HelloNative.h"
#include <stdio.h>
 
JNIEXPORT void JNICALL Java_HelloNative_sayHello
{
    printf("Hello，JNI");    
}
```
### 5.4 生成dll共享库，然后Java程序load库，调用即可。
在Windows上，MinGW GCC 运行如下
```
gcc -m64  -Wl,--add-stdcall-alias -I"C:\Program Files\Java\jdk1.7.0_71\include" -I"C:\Program Files\Java\jdk1.7.0_71\include\include\win32" -shared -o HelloNative.dll HelloNative.c
```
-m64表示生成dll库是64位的。然后运行 HelloNative：
```
java HelloNative
```
终于成功地可以看到控制台打印如下：
```
Hello，JNI
```
## 6. JAVA中的registerNatives
在JAVA中Object、Thread、System、Compiler、Class等类中都有native方法registerNatives()
```java
    private static native void registerNatives();

    static {
        registerNatives();
    }
```
registerNatives本质上就是一个本地方法，但这又是一个有别于一般本地方法的本地方法。上述代码的功能就是先定义了registerNatives()方法，然后当该类被加载的时候，调用该方法完成对该类中本地方法的注册。这里你可能会有一些疑惑，比如，到底注册了哪些方法？为什么要注册？具体又是怎么注册的？  
* 到底注册了哪些方法？细心的你可能还会发现，在Object类中，除了有registerNatives这个本地方法之外，还有hashCode()、clone()等本地方法，而在Class类中有forName0()这样的本地方法等等。也就是说，凡是包含registerNatives()本地方法的类，同时也包含了其他本地方法。所以当包含registerNatives()方法的类被加载的时候，注册的方法就是该类所包含的除了registerNatives()方法以外的所有本地方法。  
* 为什么要注册？一个Java程序要想调用一个本地方法，需要执行两个步骤：第一，通过System.loadLibrary()将包含本地方法实现的动态文件加载进内存；第二，当Java程序需要调用本地方法时，虚拟机在加载的动态文件中定位并链接该本地方法，从而得以执行本地方法。registerNatives()方法的作用就是取代第二步，让程序主动将本地方法链接到调用方，当Java程序需要调用本地方法时就可以直接调用，而不需要虚拟机再去定位并链接。
* 使用registerNatives()方法的三点好处：
(1)通过registerNatives方法在类被加载的时候就主动将本地方法链接到调用方，比当方法被使用时再由虚拟机来定位和链接更方便有效；  
(2)如果本地方法在程序运行中更新了，可以通过调用registerNative方法进行更新；  
(2)Java程序需要调用一个本地应用提供的方法时，因为虚拟机只会检索本地动态库，因而虚拟机是无法定位到本地方法实现的，这个时候就只能使用registerNatives()方法进行主动链接  
(4)通过registerNatives()方法，在定义本地方法实现的时候，可以不遵守JNI命名规范。
那什么是JNI命名规范呢？举个例子，我们在Object中定义的本地方法registerNatives，那这个方法对应的本地方法名就叫Java_java_lang_Object_registerNatives，而在System类中定义的registerNatives方法对应的本地方法名叫Java_java_lang_System_registerNatives等等。也就是说，JNI命名规范要求本地方法名由“包名”+“方法名”构成，而上面的例子中，我们将Java中定义的方法名“g”和本地方法名“g_impl”链接了起来，这就是通过registerNatives方法的第四个好处
*  第三个问题：具体怎么注册？
这个问题涉及到registerNatives()的底层C++源码实现。

参考：
1. https://hunterzhao.io/post/2018/04/06/hotspot-explore-register-natives/  【JVM源码探秘】深入registerNatives()底层实现

2. https://www.jianshu.com/p/f4b4b9006742 使用JNI_OnLoad动态注册函数

3. https://www.jianshu.com/p/216a41352fd8 JNI 学习笔记——通过RegisterNatives注册原生方法

4. https://www.cnblogs.com/findumars/p/5018184.html 关于调用约定的一点知识

5. https://www.cnblogs.com/foohack/p/4119207.html dllimport和dllexport作用与区别

6. https://blog.csdn.net/dongfengsun/article/details/1477797 DLL的Export和Import

7. https://blog.csdn.net/yuanzhihua126/article/details/78992068 JNI中JNIEnv类型和jobject类型的解释

8. https://www.jianshu.com/p/713a79293bf1 JNI 基础 - JNIEnv 的实现原理

9. https://www.jianshu.com/p/be943b4958f4 Java Object.hashCode()返回的是对象内存地址






